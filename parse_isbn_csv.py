#!/usr/bin/env python

"""
	Tool to parse a former(!) Excel (xls) file containing ISBN
	format as specified below as generated by Android App
	LoMag Barcode Scanner free (by LongInt)
	Format:
		first row: header: "item code", "Quantity", "Unit prize", "Serial number"
		first column: ISBN
	First export as CSV, then read, next extend/lookup followed by write output
	Output: varies, depends on type and available metadata
"""

import csv
import isbnlib
import sys
import logging
import argparse
import os

import bibtexparser
import json
#import docx # not in Debian?
#import pandas
import ast

#__name__ = "parse_isbn_csv"
__copyright__ = "Copyright 2018, Olaf Zevenboom"
__author__ = "Olaf Zevenboom"
__credits__ = ["Olaf Zevenboom"]
__license__ = "http://www.wtfpl.net/"
__version__ = "0.4"
__status__ = "Development"

# see for current services and limitations: https://pypi.org/project/isbnlib/
#isbn_service = 'openl'
isbn_service = 'wcat'
#isbn_service='merge'

logging.basicConfig(level=logging.DEBUG)
#logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

parser = argparse.ArgumentParser(description='ISBN CSV parser')
parser.add_argument('-i', '--input', help='Input filename', required=True)
parser.add_argument('-o', '--output', help='Output filename', required=True)
parser.add_argument('-f', '--formatter', help='type of output (bibtex, csl, msword, endnote, refworks, opf, json)')
args = parser.parse_args()

isbncsvfile = args.input
logger.info("About to start parsing ISBN CSV file: %s" % isbncsvfile)
outfile = args.output
formatter = args.formatter

logger.debug("Arg input : %s" % isbncsvfile)
logger.debug("Arg output : %s" % outfile)
logger.debug("Arg type : %s" % formatter)

"""
	input
"""
def read_input(infile):
	items = []

	if os.path.exists(infile):
		with open(infile) as csvfile:
			itemcount=-1
			readCSV = csv.reader(csvfile, delimiter=',')
			for row in readCSV:
				# first row is header info
				if itemcount>=0:
					itemcode = row[0] # ISBN
					#quantity = row[1]
					#unitprice = row[2]
					#serialnumber = row[3]
					isbn = itemcode # for now we are only interested in the first column: ISBN 
					items.append(isbn)
				itemcount += 1
	else:
		logger.info("Could not find input file: %s" % isbncsvfile)
		#exit(1) # items=NULL and handle this in main
		items = NULL
		
	return (items)

"""
	output
	get_items()
	return only valid items as specified by the formatter
	formatter options: https://github.com/xlcnd/isbnlib
"""
def get_items(items, formatter):

	logger.info("Formatter: %s" % formatter)	
	if not formatter in ["bibtex", "csl", "msword", "endnote", "refworks", "opf", "json", "csv"]:
		logger.info("Unknown formatter requested")
		return (None, items)
	if formatter == "csv": formatter='json' 
	
	logger.info("Formatter: %s" % formatter)	
	reqform = isbnlib.registry.bibformatters[formatter]

	items_ok = []
	items_with_issues = []
	
	for i, item in enumerate(items):
		logger.debug("Need to check and lookup ISBN : %s" % item)
		isbn = item # yuk, needs propper verification
		
		try:
			myitem = (reqform(isbnlib.meta(isbn, isbn_service)))
			print (myitem)
			items_ok.append(myitem)
			#print(options(formatter)) # correct isbn ?
			#print(bibtex(isbnlib.meta(isbn, isbn_service)))
			#print(json(isbnlib.meta(isbn, isbn_service)))
		except ISBNLibException as e:
			items_with_issues.append(isbn)
			pass
	return (items_ok, items_with_issues)

def write_output(myoutput, outputfile):
	# this sucks. I would like something generic
	# also add try/except construction to handle errors
	logger.info("About to write in format %s to file %s" % (formatter, outputfile))
	logger.debug("Data to be processed:")
	logger.debug(myoutput)
	logger.debug("End of data to be processed")
	try:
		with open(outputfile, 'w') as f:
			if formatter == "bibtex":
				# suggested extension: .bib
				# https://bibtexparser.readthedocs.io/en/master/tutorial.html#step-3-export
				# https://bibtexparser.readthedocs.io/en/master/bibtexparser.html#module-bibtexparser
				# give every item a separate header or can (and must!?) I add the item somehow?
				'''
				for item in myoutput:
					logger.debug("About to write: %s" % item)
					bibtexparser.dump(myoutput,f) # produces exceptions with missing fields which is troublesome!
				'''
				parser = bibtexparser.bparser.BibTexParser()
				# now tune the parser
				# https://bibtexparser.readthedocs.io/en/master/bibtexparser.html#bibtexparser-bibdatabase-the-bibliographic-database-object
				parser.ignore_nonstandard_types = False
				parser.homogenize_fields = False
				parser.interpolate_strings = False
				parser.common_strings = False
				
				mos = ''.join(myoutput)
				logger.debug("MOS = %s" % mos)
				bibdb = bibtexparser.bibdatabase.BibDatabase()
				#bibdb = bibtexparser.loads(mos, parser) # this only keeps the last item alive!
				#bibdb = mos # leads to an empty outputfile
				
				# tricky, but we can dump everything in a string where items are delimited with {} and ,
				# max string can be huge: https://stackoverflow.com/questions/1739913/what-is-the-max-length-of-a-python-string#1739928
				
				# no need, we need a dict
				bibdb.entries = outputfile
				#allentries = {}
				#for myentry in myoutput:
					
				
				#items=""
				#for item in myoutput:
				#	itemstr = bibtexparser.dumps(item, parser) # object to string, properly parsed
				#	if len(items)>0: items += ","
				#	items += "{" + itemstr + "]" 
				
				#bibdb.entries = items.split(',')

				#for item in myoutput:
				#	bibdb = bibdb + bibtexparser.dump(item, parser)
				
				# now we should have a healthy BinTeX database now, so lets export

				#logger.debug("Current BibTex datastructure:")
				#logger.debug(bibdb)
				
				
				writer = bibtexparser.bwriter.BibTexWriter()
				writer.indent = '    '     # indent entries with 4 spaces instead of one
				writer.comma_first = True  # place the comma at the beginning of the line
				
				f.write(writer.write(bibdb))
				 
			if formatter == "csl":
				# CSL-JSON
				for item in myoutput:
					logger.debug("About to write: %s" % item)
					#json.dump(item, f, indent=4)
					f.write("%s" % item)
			if formatter == "msword":
				# Source xmlns:b="http://schemas.microsoft.com/office/word/2004/10/bibliography"
				# give every item a separate header (=doc ?) or can (and must!?) I add the item somehow?
				# how does this work? A word doc per item (weird!) or ... ?
				# https://python-docx.readthedocs.io/en/latest/  <-- not supported in Debian?
				f.close()
				#document = Document(myoutput)
				#document.save(outputfile)
			if formatter == "endnote":
				# https://en.wikipedia.org/wiki/EndNote
				# for now consider it as a bunch of strings
				for item in myoutput:
					logger.debug("About to write: %s" % item)
					f.write("%s" % item)
					#print (myoutput, f)
					f.write('\n')
			if formatter == "refworks":
				# https://en.wikipedia.org/wiki/RefWorks
				# for now consider it as a bunch of strings
				for item in myoutput:
					logger.debug("About to write: %s" % item)
					f.write("%s" % item)
					#print (myoutput, f)
					f.write('\n')
			if formatter == "opf":
				# no idea!
				'''
					<?xml version='1.0' encoding='utf-8'?>
					<package version="2.0" xmlns="http://www.idpf.org/2007/opf" unique-identifier="uuid_id">
					<metadata xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:opf="http://www.idpf.org/2007/opf">
				'''
				# give every item a separate header or can (and must!?) I add the item somehow?
				for item in myoutput:
					logger.debug("About to write: %s" % item)
					f.write("%s" % item)
					#print (myoutput, f)
					f.write('\n')
			if formatter == "json":
				# BibJSON
				for item in myoutput:
					logger.debug("About to write: %s" % item)
					#json.dump(item, f, indent=4)
					f.write("%s" % item)
					
				#for item in myoutput:
				#	print ("Item : %s" % ( item))
				
				#if myoutput[1]['stat'] == 'ok':
				#	json.dump(myoutput[1]['list'], f, indent=4)
			if formatter == "csv":
				# CSV
				# http://blog.appliedinformaticsinc.com/how-to-parse-and-convert-json-to-csv-using-python/
				# https://www.techwalla.com/articles/how-to-convert-json-to-csv-in-python
				# better: http://stackabuse.com/reading-and-writing-csv-files-in-python/

				csv.register_dialect('bibcsv', delimiter=',', quoting=csv.QUOTE_NONE, quotechar='', escapechar='\\')
				
				myFields=['title', 'author', 'year', 'isbn', 'publisher']
				writer = csv.DictWriter(f, dialect='bibcsv', fieldnames=myFields)
				writer.writeheader()
				
				for item in myoutput:
					logger.debug("Item : %s" % item)
					itemdict = ast.literal_eval(item)
				
					# what to do if item part does not exist?!
					item_title      = itemdict.get('title')
					logger.debug("About to write Title: %s" % item_title)
					itemauthordict  = itemdict.get('author')[0] 
					item_author     = itemauthordict.get('name') # get first only; no co-authors, translators etc
					logger.debug("Author: %s" % item_author)
					item_year       = itemdict.get('year')
					logger.debug("Year: %s" % item_year)
					item_identifier = itemdict.get('identifier')[0]
					logger.debug("Identifier: %s" % item_identifier)
					# now check that we have an ISBN (we should have one as it is the base!)
					item_type       = item_identifier.get('type') # item_identifier.get('type')
					if (item_type.upper() == "ISBN"):
						item_isbn       = item_identifier.get('id') #item[{'identifier'}][{'id'}]
					else:
						item_isbn = ''
					item_publisher  = itemdict.get('publisher')
					writer.writerow({'title' : item_title, 'author' : item_author, 'year' : item_year, 'isbn' : item_isbn, 'publisher' : item_publisher })

			f.close()
	except IOError: #except Exception as e:
		logger.info("Unable to write output to disk")
		#logger.info(e)
		return (False)
	return (True)

def output_bibtex(items, outfile):
	logger.debug("Output %s in Bibtex format" % outfile)
	(okitems, faileditems) = get_items(items,'bibtex')
	atw = write_output(okitems, outfile)
	return (atw, faileditems)

def output_csl(items, outfile):
	logger.debug("Output %s in CSL format" % outfile)
	(okitems, faileditems) = get_items(items,'csl')
	atw = write_output(okitems, outfile)
	return (atw, faileditems)

def output_msword(items, outfile):
	logger.debug("Output %s in MSWord format" % outfile)
	okitems, faileditems = get_items(items,'msword')
	atw = write_output(okitems, outfile)
	return (atw, faileditems)

def output_endnote(items, outfile):
	logger.debug("Output %s in EndNote format" % outfile)
	okitems, faileditems = get_items(items,'endnote')
	atw = write_output(okitems, outfile)
	return (atw, faileditems)

def output_refworks(items, outfile):
	logger.debug("Output %s in RefWorks format" % outfile)
	okitems, faileditems = get_items(items,'refworks')
	atw = write_output(okitems, outfile)
	return (atw, faileditems)

def output_opf(items, outfile):
	logger.debug("Output %s in Opf format" % outfile)
	okitems, faileditems = get_items(items,'opf')
	atw = write_output(okitems, outfile)
	return (atw, faileditems)

def output_json(items, outfile):
	logger.debug("Output %s in JSON format" % outfile)
	okitems, faileditems = get_items(items,'json')
	atw = write_output(okitems, outfile)
	return (atw, faileditems)
	
def output_csv(items, outfile):
	logger.debug("Output %s in CSV format" % outfile)
	okitems, faileditems = get_items(items,'csv')
	atw = write_output(okitems, outfile)
	return (atw, faileditems)

'''
try:
	db = biblib.DibDBCollecion()
	db.addDB(biblib.FileDibDB(args.output))
	db.addDB(biblib.DoiBibDB())
	db.addDB(biblib.IsbnBibDB())
except Exception as e:
	print(e, file=sys.stderr)
	sys.exit(1)
'''

def main():
	
	items = read_input(isbncsvfile) 

	items_with_issues = []
	
	logger.debug("Outfile : %s" % outfile)
	
	options = {
		'bibtex': output_bibtex,
		'csl': output_csl, 
		'msword': output_msword, 
		'endnote': output_endnote, 
		'refworks': output_refworks,
		'opf': output_opf, 
		'json': output_json,
		'csv': output_csv,
	}
	
	#formatter= args.formatter # why does the code above fubars this var?
	
	try:
		logger.info("Outputfile of type %s selected" % formatter)
		(listitems, items_with_issues) = options[formatter](items, outfile)
		if not listitems:
			logger.info("Failed to write outputfile")
	except KeyError:
		logger.info("Unknown formatter specified as type of output")
		exit(1)
	
	no_of_all_items=len(items)
	#items_with_issues = [] # create list : # expensive: can this be done differently? (global, return tuple?)
	no_of_troublesome_items=len(items_with_issues) 
	no_of_proper_items = no_of_all_items - no_of_troublesome_items
		
	print("From the %d ISBN in the input %d had issues" % (len(items), len(items_with_issues)))
	if len(items_with_issues)>0:
		print("List of ISBN with issues : ")
		for item in items_with_issues:
			print(item)	
	print("Finished")

if __name__ == "__main__":
	main()
else:
	logger.info("Hun? __name__ = %s" % __name__)

